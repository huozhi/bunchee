// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`should compile es-advance case correctly 1`] = `
"var _foo$bar;

var foo = {
  bar: 'hello'
};
console.log('bar', foo == null ? void 0 : foo.bar);
var prop = (_foo$bar = foo.bar) != null ? _foo$bar : 'default';
console.log('name', prop);
//# sourceMappingURL=bundle.js.map
"
`;

exports[`should compile es-basic case correctly 1`] = `
"function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = \\"function\\" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || \\"@@iterator\\",
      asyncIteratorSymbol = $Symbol.asyncIterator || \\"@@asyncIterator\\",
      toStringTagSymbol = $Symbol.toStringTag || \\"@@toStringTag\\";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, \\"\\");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = \\"suspendedStart\\";
      return function (method, arg) {
        if (\\"executing\\" === state) throw new Error(\\"Generator is already running\\");

        if (\\"completed\\" === state) {
          if (\\"throw\\" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (\\"next\\" === context.method) context.sent = context._sent = context.arg;else if (\\"throw\\" === context.method) {
            if (\\"suspendedStart\\" === state) throw state = \\"completed\\", context.arg;
            context.dispatchException(context.arg);
          } else \\"return\\" === context.method && context.abrupt(\\"return\\", context.arg);
          state = \\"executing\\";
          var record = tryCatch(innerFn, self, context);

          if (\\"normal\\" === record.type) {
            if (state = context.done ? \\"completed\\" : \\"suspendedYield\\", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          \\"throw\\" === record.type && (state = \\"completed\\", context.method = \\"throw\\", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: \\"normal\\",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: \\"throw\\",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    [\\"next\\", \\"throw\\", \\"return\\"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (\\"throw\\" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && \\"object\\" == typeof value && hasOwn.call(value, \\"__await\\") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke(\\"next\\", value, resolve, reject);
        }, function (err) {
          invoke(\\"throw\\", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke(\\"throw\\", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, \\"throw\\" === context.method) {
        if (delegate.iterator.return && (context.method = \\"return\\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \\"throw\\" === context.method)) return ContinueSentinel;
        context.method = \\"throw\\", context.arg = new TypeError(\\"The iterator does not provide a 'throw' method\\");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if (\\"throw\\" === record.type) return context.method = \\"throw\\", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \\"return\\" !== context.method && (context.method = \\"next\\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \\"throw\\", context.arg = new TypeError(\\"iterator result is not an object\\"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = \\"normal\\", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: \\"root\\"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if (\\"function\\" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \\"constructor\\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \\"constructor\\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \\"GeneratorFunction\\"), exports.isGeneratorFunction = function (genFun) {
    var ctor = \\"function\\" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || \\"GeneratorFunction\\" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \\"GeneratorFunction\\")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \\"Generator\\"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, \\"toString\\", function () {
    return \\"[object Generator]\\";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \\"next\\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \\"t\\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if (\\"throw\\" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = \\"throw\\", record.arg = exception, context.next = loc, caught && (context.method = \\"next\\", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if (\\"root\\" === entry.tryLoc) return handle(\\"end\\");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, \\"catchLoc\\"),
              hasFinally = hasOwn.call(entry, \\"finallyLoc\\");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error(\\"try statement without catch or finally\\");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \\"finallyLoc\\") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && (\\"break\\" === type || \\"continue\\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \\"next\\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (\\"throw\\" === record.type) throw record.arg;
      return \\"break\\" === record.type || \\"continue\\" === record.type ? this.next = record.arg : \\"return\\" === record.type ? (this.rval = this.arg = record.arg, this.method = \\"return\\", this.next = \\"end\\") : \\"normal\\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (\\"throw\\" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error(\\"illegal catch attempt\\");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, \\"next\\" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \\"next\\", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \\"throw\\", err);
      }

      _next(undefined);
    });
  };
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return \\"__private_\\" + id++ + \\"_\\" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError(\\"attempted to use private field on non-instance\\");
  }

  return receiver;
}

var _marked = /*#__PURE__*/_regeneratorRuntime().mark(generator);

function generator() {
  return _regeneratorRuntime().wrap(function generator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return 1;

        case 2:
        case \\"end\\":
          return _context.stop();
      }
    }
  }, _marked);
}

function asyncFunc() {
  return _asyncFunc.apply(this, arguments);
}

function _asyncFunc() {
  _asyncFunc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return new Promise(function (r) {
              return r(1);
            });

          case 2:
          case \\"end\\":
            return _context3.stop();
        }
      }
    }, _callee);
  }));
  return _asyncFunc.apply(this, arguments);
}

var _x = /*#__PURE__*/_classPrivateFieldLooseKey(\\"x\\");

var A = /*#__PURE__*/function () {
  function A() {
    var _this = this;

    Object.defineProperty(this, _x, {
      writable: true,
      value: 1
    });

    this.getX = function () {
      return _classPrivateFieldLooseBase(_this, _x)[_x];
    };
  }

  var _proto = A.prototype;
  _proto.f1 = /*#__PURE__*/_regeneratorRuntime().mark(function f1() {
    return _regeneratorRuntime().wrap(function f1$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return 1;

          case 2:
          case \\"end\\":
            return _context2.stop();
        }
      }
    }, f1);
  });
  return A;
}();

var _v = 123;
var x = function x() {
  return \\"value:\\" + _v;
};

export { A, asyncFunc, generator, x };
//# sourceMappingURL=bundle.js.map
"
`;

exports[`should compile jsx case correctly 1`] = `
"function Jsx() {
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\\"div\\", null, \\"hello\\"), /*#__PURE__*/React.createElement(\\"h1\\", null, \\"yep\\"));
}

export { Jsx as default };
//# sourceMappingURL=bundle.js.map
"
`;

exports[`should compile module case correctly 1`] = `
"function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if (\\"value\\" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, \\"prototype\\", {
    writable: false
  });
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

var Parent = /*#__PURE__*/function () {
  function Parent() {}

  var _proto = Parent.prototype;

  _proto.f = function f() {
    return 1;
  };

  return Parent;
}();

var A = /*#__PURE__*/function (_Parent) {
  _inheritsLoose(A, _Parent);

  function A() {
    return _Parent.call(this) || this;
  }

  _createClass(A, [{
    key: \\"x\\",
    get: function get() {
      return _Parent.prototype.f.call(this);
    }
  }]);

  return A;
}(Parent);

var a = new A();

console.log('main', a.x);
//# sourceMappingURL=bundle.js.map
"
`;

exports[`should compile shebang case correctly 1`] = `
"#!/usr/bin/env node
console.log('shebang');
//# sourceMappingURL=bundle.js.map
"
`;

exports[`should compile sub-folder-import case correctly 1`] = `
"import ms from 'ms/index';

var input = (function () {
  return ms.apply(void 0, arguments);
});

export { input as default };
//# sourceMappingURL=bundle.js.map
"
`;

exports[`should compile ts-basic case correctly 1`] = `
"/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED \\"AS IS\\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator[\\"throw\\"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), \\"throw\\": verb(1), \\"return\\": verb(2) }, typeof Symbol === \\"function\\" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError(\\"Generator is already executing.\\");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y[\\"return\\"] : op[0] ? y[\\"throw\\"] || ((t = y[\\"return\\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var add = function (a, b) { return a + b; };

var sum = add(1, 2);
var obj = { a: 1, b: 2 };
var clone = __assign({}, obj);
function asyncFunc() {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, new Promise(function (r) { return r(1); })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    }); });
}

export { asyncFunc, clone, sum as default };
//# sourceMappingURL=bundle.js.map
"
`;

exports[`should compile ts-interop case correctly 1`] = `
"Object.defineProperty(exports, '__esModule', { value: true });

var a = { x: 1 };
var b = 'hello';

exports.b = b;
exports[\\"default\\"] = a;
//# sourceMappingURL=bundle.js.map
"
`;

exports[`should compile tsx case correctly 1`] = `
"import React from 'react';

function Tsx() {
    return (React.createElement(\\"div\\", null, \\"hello\\"));
}

export { Tsx as default };
//# sourceMappingURL=bundle.js.map
"
`;
